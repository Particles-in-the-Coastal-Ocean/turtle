# -*- coding: utf-8 -*-
"""
Created on Fri May  6 13:39:13 2016
animation
use website .csv data
@author: qzhang
"""

import csv
import urllib
import netCDF4
import sys
from decimal import *
import numpy as np
import matplotlib.pyplot as plt
import matplotlib 
from mpl_toolkits.basemap import Basemap
import pylab
import pandas as pd
from matplotlib import animation
from datetime import datetime, timedelta
from dateutil.relativedelta import relativedelta
##########hard code
filename = 'drift_ep_2016_1.csv'#'drift_ep_2016_1.csv'
title="Educational Passages Unmanned Sailboats"#the name you want show on the .gif
sttime=datetime(2016,1,1)
end_time=datetime(2016,6,23)
save_dir = './Results/'
result ='animation'#plot  animation
linetime=48#hour
showtimegap=12
add_points=1#how many points want to add between two drifter points
colors = ['cyan','olive','orange','magenta','red','purple','black','yellow']#,'green'
mapmethod='etopo'#'etopo''usgs''bluemarble'#bluemarble and etopo both belong to basemap 
track='line'#'point''line'
zoom='on'#'on'
zoom_area=[-5,-82,60,20]#[lon[max],lon[min],lat[max],lat[min]]
#####drifter data 

dtimes=[]
points = {'lats':[],'lons':[],'ids':[],'times':[],'months':[],'days':[]} 
newfilename = 'new_%s' %filename
df=pd.read_csv(filename,header=None,skiprows=1); #get the drifter data 
ids = df[0][:] 
idlist = set(ids); #the # of drifters
addtime=[]
file_data=[]
for n in idlist:
    index = np.where(df[0]==n)[0]
    ddata = df.ix[index];

    dtimes=[]
    syear=str(ddata[0][index[0]])[0:2]
    for i in index:
        lon=ddata[7][i]
        lat=ddata[8][i]
        month=ddata[2][i]
        day=ddata[3][i]
        hour=ddata[4][i]
        minute=ddata[5][i]
        if zoom=='on':
            if lon<=zoom_area[0] and lon>=zoom_area[1] and lat<zoom_area[2] and lat>zoom_area[3] :
                
                time='20'+str(syear)+'-'+str(month)+'-'+str(day)+' '+str(hour)+':'+str(minute)
                
                dtimes.append(datetime.strptime(time, '%Y-%m-%d'+' '+'%H:%M' ))

                    
                if len(dtimes)==1:
                    pass
                elif dtimes[-1]<dtimes[-2]:
                    dtimes[-1]=dtimes[-1] + relativedelta(years=1)
                    syear=int(syear)+1
                    #print dtimes[-1],dtimes[-2]
    
                if dtimes[-1]>sttime and dtimes[-1]<end_time:
                    points['times'].extend([dtimes[-1]])#.strftime('%Y-%m-%d %H:%M'))
                    points['lons'].extend([lon]); points['lats'].extend([lat]);
                    points['ids'].extend([n]);points['months'].extend([month]);points['days'].extend([day])   
        if zoom=='off':
            time='20'+str(syear)+'-'+str(month)+'-'+str(day)+' '+str(hour)+':'+str(minute)
                
            dtimes.append(datetime.strptime(time, '%Y-%m-%d'+' '+'%H:%M' ))
        

            if len(dtimes)==1:
                pass
            elif dtimes[-1]<dtimes[-2]:
                #print 1
                dtimes[-1]=dtimes[-1] + relativedelta(years=1)
                syear=int(syear)+1


            if dtimes[-1]>sttime and dtimes[-1]<end_time:
                points['times'].extend([dtimes[-1]])#.strftime('%Y-%m-%d %H:%M'))
                points['lons'].extend([lon]); points['lats'].extend([lat]);
                points['ids'].extend([n]);points['months'].extend([month]);points['days'].extend([day])   
mintime=min(points['times'])     
#print mintime   
file_data.append(points['ids'])
file_data.append(points['months'])
file_data.append(points['days'])
file_data.append(points['times'])
file_data.append(points['lons'])
file_data.append(points['lats'])

dr=map(list, zip(*file_data))

###make a list
csvfile = file(newfilename, 'wb')
writer = csv.writer(csvfile)
writer.writerow(['ids', 'month', 'day','time','lon','lat'])
writer.writerows(dr)
csvfile.close() 

df=pd.read_csv(newfilename,header=None,skiprows=1); #get the drifter data 
ids = df[0][:] 
idlist = set(ids); #the # of drifters
print idlist

#######basemap and function
def draw_basemap(ax, points, interval_lon=10, interval_lat=10):#we use interval_lon control the longitude  tick labels
    '''
    use basemap function draw the map 
    we use interval_lon control the longitude tick labels on axis
    when we use 'etopo' ,the file will bigger than 'bluemarble' 
    '''
    
    lons = points['lons']
    lats = points['lats']
    size = max((max(lons)-min(lons)),(max(lats)-min(lats)))/25
    size=size*2
    '''map_lon = [-72,-65]
    map_lat = [40,45]'''
    map_lon = [min(lons)-size,max(lons)+size]
    map_lat = [min(lats)-size,max(lats)+size]
    
    #ax = fig.sca(ax)
    dmap = Basemap(projection='cyl',
                   llcrnrlat=map_lat[0], llcrnrlon=map_lon[0],
                   urcrnrlat=map_lat[1], urcrnrlon=map_lon[1],
                   resolution='f',ax=ax)# resolution: c,l,i,h,f.
    dmap.drawparallels(np.arange(int(map_lat[0])-1,
                                 int(map_lat[1])+1,interval_lat),
                       labels=[1,0,0,0])
    dmap.drawmeridians(np.arange(int(map_lon[0])-1,
                                 int(map_lon[1])+1,interval_lon),
                       labels=[0,0,0,1])
    #dmap.drawcoastlines()# draw the coast line
    dmap.fillcontinents(color='grey')
    if mapmethod=='etopo':
        dmap.etopo()#use this one make .gif file bigger than use bluemarble 
    elif mapmethod=='bluemarble':
        dmap.bluemarble()#choose this one or etopo
    #dmap.drawmapboundary()


def lat2str(deg):
    min = 60 * (deg - np.floor(deg))
    deg = np.floor(deg)
    dir = 'N'
    if deg < 0:
        if min != 0.0:
            deg += 1.0
            min -= 60.0
        dir = 'S'
    if np.floor(min)==0:        
      return (u"%d\N{DEGREE SIGN}%s") % (np.abs(deg),dir)
    else:  
      return (u"%d\N{DEGREE SIGN} %g' %s") % (np.abs(deg),np.abs(min),dir)
  
def lon2str(deg):
    min = 60 * (deg - np.floor(deg))
    deg = np.floor(deg)
    dir = 'E'
    if deg < 0:
        if min != 0.0:
            deg += 1.0
            min -= 60.0
        dir = 'W'
    if np.floor(min)==0:        
      return (u"%d\N{DEGREE SIGN}%s") % (np.abs(deg),dir)
    else:  
      return (u"%d\N{DEGREE SIGN} %g' %s") % (np.abs(deg),np.abs(min),dir)

   
def basemap_usgs(points,bathy,cont_range,ss):
    #plot the coastline and, if bathy is True, bathymetry is plotted
    # lat and lon can be any list of positions in decimal degrees
    #parallels_interval is the tick interval on axis
    #cont_range is the depth contours to plot
    #ss is the subsample rate to make things quicker
    lon = points['lons']
    lat = points['lats']

    #url='http://geoport.whoi.edu/thredds/dodsC/bathy/crm_vol1.nc'
    def get_index_latlon():# use the function to calculate the minlat,minlon,maxlat,maxlon location

        base_url='http://coastwatch.pfeg.noaa.gov/erddap/griddap/usgsCeSrtm30v6.nc?'
        isub=1  # make isub =1 in production mode
        if type(lat)!=float:
          query='topo[(%f):%d:(%f)][(%f):%d:(%f)]' % (max(lat),isub,min(lat),min(lon),isub,max(lon))
        else:
          query='topo[(%f):%d:(%f)][(%f):%d:(%f)]' % (lat+3.1,isub,lat-3.1,lon-3.1,isub,lon+3.1)
        url = base_url+query
        file='usgsCeSrtm30v6.nc'
        urllib.urlretrieve (url, file)
        nc = netCDF4.Dataset(file)
        ncv = nc.variables
    
        basemap_lat=ncv['latitude'][:]
        basemap_lon=ncv['longitude'][:]
        basemap_topo=ncv['topo'][:]
        #print basemap_lat
        # add the detail of basemap
        minlat=min(lat)#-0.01
        maxlat=max(lat)#+0.01
        minlon=min(lon)#-0.01
        maxlon=max(lon)#+0.01
        index_minlat=int(round(np.interp(minlat,basemap_lat,range(0,basemap_lat.shape[0]))))
        index_maxlat=int(round(np.interp(maxlat,basemap_lat,range(0,basemap_lat.shape[0]))))
        index_minlon=int(round(np.interp(minlon,basemap_lon,range(0,basemap_lon.shape[0]))))
        index_maxlon=int(round(np.interp(maxlon,basemap_lon,range(0,basemap_lon.shape[0]))))
        return index_minlat,index_maxlat,index_minlon,index_maxlon,basemap_lat,basemap_lon,basemap_topo
    
    index_minlat,index_maxlat,index_minlon,index_maxlon,basemap_lat,basemap_lon,basemap_topo = get_index_latlon()
 
    min_index_lat=min(index_minlat,index_maxlat)
    max_index_lat=max(index_minlat,index_maxlat)
    min_index_lon=min(index_minlon,index_maxlon)
    max_index_lon=max(index_minlon,index_maxlon)
    #ss=5 #subsample
    print "Using the USGS high res bathy with topo indexes: "+str(min_index_lat)+','+str(max_index_lat)+','+str(min_index_lon)+','+str(max_index_lon)
    X,Y=np.meshgrid(basemap_lon[min_index_lon:max_index_lon:ss],basemap_lat[min_index_lat:max_index_lat:ss])

    # You can set negative contours to be solid instead of dashed:
    matplotlib.rcParams['contour.negative_linestyle'] = 'solid'
    if bathy==True:
        #CS=plt.contourf(X,Y,basemap_topo.topo[min_index_lat:max_index_lat:ss,index_minlon:index_maxlon:ss],cont_range)#,colors=['0.8'])#,linewith=0.05)#cont_range)#,colors=['0.75','0.80','0.85','0.90'],linewith=0.05)
        CS=plt.contour(X,Y,basemap_topo[min_index_lat:max_index_lat:ss,index_minlon:index_maxlon:ss],cont_range,linewidths=0.5)#cont_range)#,colors=['0.75','0.80','0.85','0.90'],linewith=0.05)
        plt.clabel(CS, fmt='%5.0f m', colors='b', fontsize=8)

    if min_index_lat==max_index_lat:
        print "No basemap_usgs data available for this area"
    else: 
        plt.contourf(X,Y,basemap_topo[min_index_lat:max_index_lat:ss,min_index_lon:max_index_lon:ss],[0,1000],colors='0.5')
        
########animation    
if sttime<mintime   :
    start_time=mintime
else:
    start_time=sttime
points = {'lats':[],'lons':[]}  # collect all points we've gained
lons = []; lats = []; loop_num = []; times =[]; ctime = []; toltime = [] #mint = []; maxt = []

for i in idlist:
    index = np.where(df[0]==i)[0]
    ddata = df.ix[index]; 
    points['lons'].extend(ddata[4]); points['lats'].extend(ddata[5])
    ts = []; ds = []
    year=start_time.year
    for j in range(len(ddata)):

        strt=ddata[3][index[j]]
        temptime = datetime.strptime(strt,'%Y-%m-%d'+' '+'%H:%M:%S')
        ts.append(temptime) #'''
        ths = (temptime - start_time).total_seconds()/3600
        ds.append(int(round(ths)))

        
    #mint.append(min(ds)); maxt.append(max(ds))
    times.append(np.array(ts)); ctime.append(np.array(ds)); toltime.extend(ds)
    lons.append(np.array(ddata[4])); lats.append(np.array(ddata[5]))
    loop_num.append(len(ddata[4]))
    #print times
#mintime = min(mint); maxtime = max(maxt)
#mtime = range(mintime,maxtime+1)
toltime = set(toltime); 
toltime = list(toltime); toltime.sort(); print 'plotting...',len(toltime)



if result == 'plot':
    for i in range(len(lons)):
        plt.plot(lons[i],lats[i],'-',color = colors[i%10],markersize=20)

#ax.plot(drifter_points['lon'],drifter_points['lat'],'bo-',markersize=6,label='Drifter')
'''ax.annotate(an2,xy=(dr_points['lon'][-1],dr_points['lat'][-1]),xytext=(dr_points['lon'][-1]+0.01*track_days,
            dr_points['lat'][-1]+0.01*track_days),fontsize=6,arrowprops=dict(arrowstyle="fancy"))#'''


    
#compare to the 'animation','banimation' is more fit the file which have more drifter  or more data 
if result == 'animation':
    ailoops = int((toltime[-1]-toltime[0])/showtimegap)
    print 'frame:',ailoops
    def animate(n):
        #print n
        del ax.lines[:]#del ax.collections[:]ax.cla()

        supt = (start_time + n*timedelta(hours=showtimegap)).strftime('%Y-%m-%d')          
        drawst=start_time + n*timedelta(hours=showtimegap)
        drawend=drawst+timedelta(hours=linetime)
        #print supt        
        plt.suptitle('%s  \n date: %s'%(title,supt),fontsize=12)   
        
        for i in range(len(lons)): #loop drifters
            #print times[i],toltime[0]+n*showtimegap
            std=times[i]-drawst
            sindex = np.argmin(abs(std))
            etd=times[i]-drawend
            eindex = np.argmin(abs(etd))
            print drawst,drawend,sindex,eindex
            seglength=eindex-sindex
            print seglength
            c = colors[i%len(colors)]
            if track=='line':
                #print ctime[i],(toltime[0]+n*showtimegap)
    
                abct = ctime[i] - (toltime[0]+n*showtimegap)
                #print abct
                ni = np.argmin(abs(abct)); 
                #print ni
                if ni<seglength:

                    while (ni>=0):
                        if ni>7:
                            ax.plot(lons[i][ni],lats[i][ni],'o',color=c,markersize=8,markeredgecolor = 'none')
                        else:
                            ax.plot(lons[i][ni],lats[i][ni],'o',color=c,markersize=ni+1,markeredgecolor = 'none')
                        ni=ni-1
                else:
                    marksize=7
                    for k in range(seglength):
                        if marksize==2:
                            pass
                        else:
                            marksize=marksize-1
                        linew=marksize-1.5      
                        ax.plot(lons[i][ni-k],lats[i][ni-k],'o-',color=c,markersize=marksize,markeredgecolor = 'none')
                        ax.plot([lons[i][ni-k-1],lons[i][ni-k]],[lats[i][ni-k-1],lats[i][ni-k]],'-', color=c,linewidth=linew)                           

            elif track=='point':
                if toltime[n] > ctime[i][-1]:
                    if toltime[n-seglength]<ctime[i][-1]:
                        lki = ctime[i] - toltime[n-seglength]
                        nik = np.argmin(abs(lki)); 
                        wlp = len(ctime[i])-nik
                        for j in range(wlp):
                            ax.plot(lons[i][-(j+1)],lats[i][-(j+1)],'o-',color=c,markersize=wlp-j+1,markeredgecolor = 'none')                  

                        
                    else:
    
                        ax.plot(lons[i][-1],lats[i][-1],'o-',color=c,markersize=10)
                else:
    
                    abct = ctime[i] - toltime[n]
                    ni = np.argmin(abs(abct)); 
                    
                    if ni<seglength:
                        while (ni>=0):
                            ax.plot(lons[i][ni],lats[i][ni],'o',color=c,markersize=ni+1,markeredgecolor = 'none')
                            ni=ni-1

                    else:

                        for k in range(seglength):
                            ax.plot(lons[i][ni-k],lats[i][ni-k],'o-',color=c,markersize=seglength-k,markeredgecolor = 'none')

   
    
    if mapmethod=='etopo' or mapmethod=='bluemarble':
        fig = plt.figure() #figsize=(10,9)
        #can use this to control where the picture is 
        ax = fig.add_subplot(111)
        draw_basemap(ax, points)  # points is using here
        print 1
        anim = animation.FuncAnimation(fig, animate, frames=ailoops, interval=100) 
    elif mapmethod=='usgs':
        fig = plt.figure(figsize=(10,9)) #figsize=(16,12)
        #can use this to control where the picture is 
        ax = fig.add_subplot(111)
        basemap_usgs(points,True,[-40,-30,-20,-10,0],1)
        thismanager3 = pylab.get_current_fig_manager()
        anim = animation.FuncAnimation(fig, animate, frames=ailoops, interval=100) 
    en_run_time = datetime.now()
    # mencoder,imagemagick,ffmpeg
anim.save(save_dir+'%s.gif'%(filename[:-4]),writer='imagemagick',dpi=100)#file name
plt.show()

