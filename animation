# -*- coding: utf-8 -*-
"""
Created on Fri May  6 13:39:13 2016
animation
use website .csv data
@author: qzhang
"""

import csv
import urllib
import netCDF4
import sys
from decimal import *
import numpy as np
import matplotlib.pyplot as plt
import matplotlib 
from mpl_toolkits.basemap import Basemap
import pylab
import pandas as pd
from matplotlib import animation
from datetime import datetime, timedelta
from dateutil.relativedelta import relativedelta
##########hard code
filename = 'drift_X.csv'#'drift_ep_2016_1.csv'
title="NOAA_drifters"#the name you want show on the .gif
sttime=datetime(2015,1,1)
end_time=datetime(2016,6,30)
save_dir = './Results/'
result ='animation'#plot  animation
linetime=48#hour
showtime_period=12
add_points=1#how many points want to add between two drifter points
colors = ['cyan','olive','orange','magenta','red','purple','black','blue']#,yellow'green'
mapmethod='usgs'#'etopo''usgs''bluemarble'#bluemarble and etopo both belong to basemap 
track='line'#'point''line''spline'
zoom='on'#'on'
zoom_area=[-66.5,-71,42.5,39.75]#[lon[max],lon[min],lat[max],lat[min]]
bathymetric=[-200,-150,-100,-50,0]
interval_lon=1
interval_lat=1
#####drifter data 

dtimes=[]
points = {'lats':[],'lons':[],'ids':[],'times':[],'months':[],'days':[],'depths':[]} 
newfilename = 'new_%s' %filename
df=pd.read_csv(filename,header=None,skiprows=1); #get the drifter data 
ids = df[0][:] 
idlist = set(ids); #the # of drifters
addtime=[]
file_data=[]
for n in idlist:
    index = np.where(df[0]==n)[0]
    ddata = df.ix[index];

    dtimes=[]
    syear=str(ddata[0][index[0]])[0:2]
    for i in index:
        lon=ddata[7][i]
        lat=ddata[8][i]
        month=ddata[2][i]
        day=ddata[3][i]
        hour=ddata[4][i]
        minute=ddata[5][i]
        depth=ddata[9][i]
        #print depth
        if zoom=='on':
            if lon<=zoom_area[0] and lon>=zoom_area[1] and lat<zoom_area[2] and lat>zoom_area[3] and depth<=-0.2 :
                #print 1
                time='20'+str(syear)+'-'+str(month)+'-'+str(day)+' '+str(hour)+':'+str(minute)
                
                dtimes.append(datetime.strptime(time, '%Y-%m-%d'+' '+'%H:%M' ))
                    
                if len(dtimes)==1:
                    pass
                elif dtimes[-1]<dtimes[-2]:
                    dtimes[-1]=dtimes[-1] + relativedelta(years=1)
                    syear=int(syear)+1
                    #print dtimes[-1],dtimes[-2]
    
                if dtimes[-1]>sttime and dtimes[-1]<end_time:
                    #print dtimes[-1]
                    points['times'].extend([dtimes[-1]])#.strftime('%Y-%m-%d %H:%M'))
                    points['depths'].extend([depth])
                    points['lons'].extend([lon]); points['lats'].extend([lat]);
                    points['ids'].extend([n]);points['months'].extend([month]);points['days'].extend([day])   
        if zoom=='off':
            time='20'+str(syear)+'-'+str(month)+'-'+str(day)+' '+str(hour)+':'+str(minute)
                
            dtimes.append(datetime.strptime(time, '%Y-%m-%d'+' '+'%H:%M' ))
        

            if len(dtimes)==1:
                pass
            elif dtimes[-1]<dtimes[-2]:
                #print 1
                dtimes[-1]=dtimes[-1] + relativedelta(years=1)
                syear=int(syear)+1


            if dtimes[-1]>sttime and dtimes[-1]<end_time:
                points['times'].extend([dtimes[-1]])#.strftime('%Y-%m-%d %H:%M'))
                points['lons'].extend([lon]); points['lats'].extend([lat]);
                points['ids'].extend([n]);points['months'].extend([month]);points['days'].extend([day])   
mintime=min(points['times'])     
#print mintime   
file_data.append(points['ids'])
file_data.append(points['months'])
file_data.append(points['days'])
file_data.append(points['times'])
file_data.append(points['lons'])
file_data.append(points['lats'])
file_data.append(points['depths'])

dr=map(list, zip(*file_data))

###make a list
csvfile = file(newfilename, 'wb')
writer = csv.writer(csvfile)
writer.writerow(['ids', 'month', 'day','time','lon','lat','depth'])
writer.writerows(dr)
csvfile.close() 

df=pd.read_csv(newfilename,header=None,skiprows=1); #get the drifter data 
ids = df[0][:] 
idlist = set(ids); #the # of drifters
print idlist

#######basemap and function
def draw_basemap(ax,  interval_lon, interval_lat):#we use interval_lon control the longitude  tick labels
    '''
    use basemap function draw the map 
    we use interval_lon control the longitude tick labels on axis
    when we use 'etopo' ,the file will bigger than 'bluemarble' 
    '''
    dmap = Basemap(projection='cyl',
                   llcrnrlat=zoom_area[3], llcrnrlon=zoom_area[1],
                   urcrnrlat=zoom_area[2], urcrnrlon=zoom_area[0],
                   resolution='f',ax=ax)# resolution: c,l,i,h,f.
    dmap.drawparallels(np.arange(int(zoom_area[3]),
                                 int(zoom_area[2]),interval_lat),
                       labels=[1,0,0,0])
    dmap.drawmeridians(np.arange(int(zoom_area[1]),
                                 int(zoom_area[0]),interval_lon),
                       labels=[0,0,0,1])
    #dmap.drawcoastlines()# draw the coast line
    dmap.fillcontinents(color='grey')
    if mapmethod=='etopo':
        dmap.etopo()#use this one make .gif file bigger than use bluemarble 
    elif mapmethod=='bluemarble':
        dmap.bluemarble()#choose this one or etopo

def lat2str(deg):
    min = 60 * (deg - np.floor(deg))
    deg = np.floor(deg)
    dir = 'N'
    if deg < 0:
        if min != 0.0:
            deg += 1.0
            min -= 60.0
        dir = 'S'
    if np.floor(min)==0:        
      return (u"%d\N{DEGREE SIGN}%s") % (np.abs(deg),dir)
    else:  
      return (u"%d\N{DEGREE SIGN} %g' %s") % (np.abs(deg),np.abs(min),dir)
  
def lon2str(deg):
    min = 60 * (deg - np.floor(deg))
    deg = np.floor(deg)
    dir = 'E'
    if deg < 0:
        if min != 0.0:
            deg += 1.0
            min -= 60.0
        dir = 'W'
    if np.floor(min)==0:        
      return (u"%d\N{DEGREE SIGN}%s") % (np.abs(deg),dir)
    else:  
      return (u"%d\N{DEGREE SIGN} %g' %s") % (np.abs(deg),np.abs(min),dir)

   
def basemap_usgs(bathy,cont_range,ss):
    #plot the coastline and, if bathy is True, bathymetry is plotted
    # lat and lon can be any list of positions in decimal degrees
    #parallels_interval is the tick interval on axis
    #cont_range is the depth contours to plot
    #ss is the subsample rate to make things quicker





    #print map_lon,map_lat
    #ax = fig.sca(ax)
    dmap = Basemap(projection='cyl',
                   llcrnrlat=zoom_area[3], llcrnrlon=zoom_area[1],
                   urcrnrlat=zoom_area[2], urcrnrlon=zoom_area[0],
                   resolution='f',ax=ax)# resolution: c,l,i,h,f.
    dmap.drawparallels(np.arange(int(zoom_area[3]),
                                 int(zoom_area[2]),interval_lat),
                       labels=[1,0,0,0])
    dmap.drawmeridians(np.arange(int(zoom_area[1]),
                                 int(zoom_area[0]),interval_lon),
                       labels=[0,0,0,1])
    #dmap.drawcoastlines()# draw the coast line
    dmap.fillcontinents(color='grey')
    #url='http://geoport.whoi.edu/thredds/dodsC/bathy/crm_vol1.nc'
    minlat=zoom_area[3]#-0.01
    maxlat=zoom_area[2]#+0.01
    minlon=zoom_area[1]#-0.01
    maxlon=zoom_area[0]#+0.01

    base_url='http://coastwatch.pfeg.noaa.gov/erddap/griddap/usgsCeSrtm30v6.nc?'
    isub=1  # make isub =1 in production mode

    query='topo[(%f):%d:(%f)][(%f):%d:(%f)]' % (maxlat,isub,minlat,minlon,isub,maxlon)

    url = base_url+query
    file='usgsCeSrtm30v6.nc'
    urllib.urlretrieve (url, file)
    nc = netCDF4.Dataset(file)
    ncv = nc.variables

    basemap_lat=ncv['latitude'][:]
    basemap_lon=ncv['longitude'][:]
    basemap_topo=ncv['topo'][:]
    #print basemap_lat

    index_minlat=int(round(np.interp(zoom_area[3],basemap_lat,range(0,basemap_lat.shape[0]))))
    index_maxlat=int(round(np.interp(zoom_area[2],basemap_lat,range(0,basemap_lat.shape[0]))))
    index_minlon=int(round(np.interp(zoom_area[1],basemap_lon,range(0,basemap_lon.shape[0]))))
    index_maxlon=int(round(np.interp(zoom_area[0],basemap_lon,range(0,basemap_lon.shape[0]))))
    
    min_index_lat=min(index_minlat,index_maxlat)
    max_index_lat=max(index_minlat,index_maxlat)
    min_index_lon=min(index_minlon,index_maxlon)
    max_index_lon=max(index_minlon,index_maxlon)
    #ss=5 #subsample
    print "Using the USGS high res bathy with topo indexes: "+str(min_index_lat)+','+str(max_index_lat)+','+str(min_index_lon)+','+str(max_index_lon)
    X,Y=np.meshgrid(basemap_lon[min_index_lon:max_index_lon:ss],basemap_lat[min_index_lat:max_index_lat:ss])

    # You can set negative contours to be solid instead of dashed:
    matplotlib.rcParams['contour.negative_linestyle'] = 'solid'
    if bathy==True:
        #CS=plt.contourf(X,Y,basemap_topo.topo[min_index_lat:max_index_lat:ss,index_minlon:index_maxlon:ss],cont_range)#,colors=['0.8'])#,linewith=0.05)#cont_range)#,colors=['0.75','0.80','0.85','0.90'],linewith=0.05)
        CS=plt.contour(X,Y,basemap_topo[min_index_lat:max_index_lat:ss,index_minlon:index_maxlon:ss],cont_range,linewidths=0.5)#cont_range)#,colors=['0.75','0.80','0.85','0.90'],linewith=0.05)
        plt.clabel(CS, fmt='%5.0f m', colors='b', fontsize=8)

    if min_index_lat==max_index_lat:
        print "No basemap_usgs data available for this area"
    #else: 
       #plt.contourf(X,Y,basemap_topo[min_index_lat:max_index_lat:ss,min_index_lon:max_index_lon:ss],[0,1000],colors='0.5')

########animation    
if sttime<mintime   :
    start_time=mintime
else:
    start_time=sttime
points = {'lats':[],'lons':[]}  # collect all points we've gained
lons = []; lats = []; loop_num = []; times =[]; ctime = []; toltime = [] #mint = []; maxt = []

for i in idlist:
    index = np.where(df[0]==i)[0]
    ddata = df.ix[index]; 
    points['lons'].extend(ddata[4]); points['lats'].extend(ddata[5])
    ts = []; ds = []
    year=start_time.year
    for j in range(len(ddata)):

        strt=ddata[3][index[j]]
        temptime = datetime.strptime(strt,'%Y-%m-%d'+' '+'%H:%M:%S')
        ts.append(temptime) #'''
        ths = (temptime - start_time).total_seconds()/3600
        ds.append(int(round(ths)))

        
    #mint.append(min(ds)); maxt.append(max(ds))
    times.append(np.array(ts)); ctime.append(np.array(ds)); toltime.extend(ds)
    lons.append(np.array(ddata[4])); lats.append(np.array(ddata[5]))
    loop_num.append(len(ddata[4]))
    #print times
#mintime = min(mint); maxtime = max(maxt)
#mtime = range(mintime,maxtime+1)
toltime = set(toltime); 
toltime = list(toltime); toltime.sort(); print 'plotting...',len(toltime)



if result == 'plot':
    for i in range(len(lons)):
        plt.plot(lons[i],lats[i],'-',color = colors[i%10],markersize=20)

#ax.plot(drifter_points['lon'],drifter_points['lat'],'bo-',markersize=6,label='Drifter')
'''ax.annotate(an2,xy=(dr_points['lon'][-1],dr_points['lat'][-1]),xytext=(dr_points['lon'][-1]+0.01*track_days,
            dr_points['lat'][-1]+0.01*track_days),fontsize=6,arrowprops=dict(arrowstyle="fancy"))#'''


    
#compare to the 'animation','banimation' is more fit the file which have more drifter  or more data 
if result == 'animation':
    ailoops = int((toltime[-1]-toltime[0])/showtime_period)
    print 'frame:',ailoops
    def animate(n):
        #print n
        del ax.lines[:]#del ax.collections[:]ax.cla()

        supt = (start_time + n*timedelta(hours=showtime_period)).strftime('%Y-%m-%d')          
        drawst=start_time + n*timedelta(hours=showtime_period)
        drawend=drawst+timedelta(hours=linetime)
        #print supt        
        plt.suptitle('%s  \n date: %s'%(title,supt),fontsize=12)   
        
        for i in range(len(lons)): #loop drifters
            #print times[i],toltime[0]+n*showtimegap
            std=times[i]-drawst
            sindex = np.argmin(abs(std))
            etd=times[i]-drawend
            eindex = np.argmin(abs(etd))

            seglength=eindex-sindex

            c = colors[i%len(colors)]
            if track=='line':
                #print ctime[i],(toltime[0]+n*showtimegap)
    
                abct = ctime[i] - (toltime[0]+n*showtime_period)
                #print abct
                ni = np.argmin(abs(abct)); 
                #print ni
                if ni<seglength:

                    while (ni>=0):
                        if ni>7:
                            ax.plot(lons[i][ni],lats[i][ni],'o',color=c,markersize=8,markeredgecolor = 'none')
                        else:
                            ax.plot(lons[i][ni],lats[i][ni],'o',color=c,markersize=ni+1,markeredgecolor = 'none')
                        ni=ni-1
                else:
                    marksize=7
                    for k in range(seglength):
                        if marksize==2:
                            pass
                        else:
                            marksize=marksize-1
                        linew=marksize-1.5      
                        ax.plot(lons[i][ni-k],lats[i][ni-k],'o-',color=c,markersize=marksize,markeredgecolor = 'none')
                        ax.plot([lons[i][ni-k-1],lons[i][ni-k]],[lats[i][ni-k-1],lats[i][ni-k]],'-', color=c,linewidth=linew)                           

            elif track=='point':
                if toltime[n] > ctime[i][-1]:
                    if toltime[n-seglength]<ctime[i][-1]:
                        lki = ctime[i] - toltime[n-seglength]
                        nik = np.argmin(abs(lki)); 
                        wlp = len(ctime[i])-nik
                        for j in range(wlp):
                            ax.plot(lons[i][-(j+1)],lats[i][-(j+1)],'o-',color=c,markersize=wlp-j+1,markeredgecolor = 'none')                  

                        
                    else:
    
                        ax.plot(lons[i][-1],lats[i][-1],'o-',color=c,markersize=10)
                else:
    
                    abct = ctime[i] - toltime[n]
                    ni = np.argmin(abs(abct)); 
                    
                    if ni<seglength:
                        while (ni>=0):
                            ax.plot(lons[i][ni],lats[i][ni],'o',color=c,markersize=ni+1,markeredgecolor = 'none')
                            ni=ni-1

                    else:

                        for k in range(seglength):
                            ax.plot(lons[i][ni-k],lats[i][ni-k],'o-',color=c,markersize=seglength-k,markeredgecolor = 'none')

            elif track=='spline':
                abct = ctime[i] - (toltime[0]+n*showtime_period)
                #print abct
                ni = np.argmin(abs(abct)); 
                #print ni
                if seglength<4:
                    ax.plot(lons[i][ni],lats[i][ni],'o',color=c,markersize=ni+1,markeredgecolor = 'none')
                else:
                    if ni<seglength:
    
                        while (ni>=0):
                            if ni>7:
                                ax.plot(lons[i][ni],lats[i][ni],'o',color=c,markersize=8,markeredgecolor = 'none')
                            else:
                                ax.plot(lons[i][ni],lats[i][ni],'o',color=c,markersize=ni+1,markeredgecolor = 'none')
                            ni=ni-1
                    else:
                        marksize=7
                        for k in range(seglength):
                            if marksize==2:
                                pass
                            else:
                                marksize=marksize-1
                            linew=marksize-1.5      
                            ax.plot(lons[i][ni-k],lats[i][ni-k],'o-',color=c,markersize=marksize,markeredgecolor = 'none')
                            ax.plot([lons[i][ni-k-1],lons[i][ni-k]],[lats[i][ni-k-1],lats[i][ni-k]],'-', color=c,linewidth=linew)                           
    
        
    if mapmethod=='etopo' or mapmethod=='bluemarble':
        fig = plt.figure() #figsize=(10,9)
        #can use this to control where the picture is 
        ax = fig.add_subplot(111)
        draw_basemap(ax, interval_lon,interval_lat)  # points is using here
        anim = animation.FuncAnimation(fig, animate, frames=ailoops, interval=100) 
    elif mapmethod=='usgs':
        fig = plt.figure() #figsize=(16,12)
        #can use this to control where the picture is 
        ax = fig.add_subplot(111)
        basemap_usgs(True,bathymetric,1)
        thismanager3 = pylab.get_current_fig_manager()
        anim = animation.FuncAnimation(fig, animate, frames=ailoops, interval=100) 
    
    en_run_time = datetime.now()
    # mencoder,imagemagick,ffmpeg
if zoom=='on':
    anim.save(save_dir+'%s_zoom.gif'%(filename[:-4]),writer='imagemagick',dpi=100)#file name
else:
    anim.save(save_dir+'%s.gif'%(filename[:-4]),writer='imagemagick',dpi=100)#file name
plt.show()

