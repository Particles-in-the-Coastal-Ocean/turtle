# -*- coding: utf-8 -*-
"""
Created on Fri May  6 13:39:13 2016
animation

@author: qzhang
"""
import urllib
import netCDF4
import sys
from decimal import *
import numpy as np
import matplotlib.pyplot as plt
import matplotlib 
from mpl_toolkits.basemap import Basemap
import pylab
import pandas as pd
from matplotlib import animation
from datetime import datetime, timedelta

##########hard code
filename = 'drift_X.dat'
title="2016 drifters"
save_dir = './Results/'
result = 'banimation'#if file have many data use banimation else use animation
basetime = datetime(2015,1,1)
drpoint_number=5#how many  point number for one drifter you want to show on the  .gif
add_points=0#how many points want to add between two drifter points
colors = ['cyan','green','blue','olive','orange','magenta','red','purple','black','yellow']
mapmethod='bluemarble'#'etopo''usgs''bluemarble'
track='line'#'point''line'
#####drifter data 
df=pd.read_csv(filename,header=None,skiprows=1); #get the drifter data 
print filename
ids = df[0][:] 
idlist = set(ids); #the # of drifters
print idlist
#######basemap and function
def draw_basemap(ax, points, interval_lon=5, interval_lat=5):#we use interval_lon control the longitude  tick labels
    '''
    draw the basemap?
    '''
    
    lons = points['lons']
    lats = points['lats']
    size = max((max(lons)-min(lons)),(max(lats)-min(lats)))/25
    size=size*2
    '''map_lon = [-72,-65]
    map_lat = [40,45]'''
    map_lon = [min(lons)-size,max(lons)+size]
    map_lat = [min(lats)-size,max(lats)+size]
    
    #ax = fig.sca(ax)
    dmap = Basemap(projection='cyl',
                   llcrnrlat=map_lat[0], llcrnrlon=map_lon[0],
                   urcrnrlat=map_lat[1], urcrnrlon=map_lon[1],
                   resolution='f',ax=ax)# resolution: c,l,i,h,f.
    dmap.drawparallels(np.arange(int(map_lat[0])-1,
                                 int(map_lat[1])+1,interval_lat),
                       labels=[1,0,0,0])
    dmap.drawmeridians(np.arange(int(map_lon[0])-1,
                                 int(map_lon[1])+1,interval_lon),
                       labels=[0,0,0,1])
    #dmap.drawcoastlines()
    dmap.fillcontinents(color='grey')
    if mapmethod=='etopo':
        dmap.etopo()#use this one make .gif file bigger than use bluemarble 
    elif mapmethod=='bluemarble':
        dmap.bluemarble()#choose this one or etopo
    #dmap.drawmapboundary()
    #dmap.etopo()#use this one make .gif file bigger than use bluemarble 

def lat2str(deg):
    min = 60 * (deg - np.floor(deg))
    deg = np.floor(deg)
    dir = 'N'
    if deg < 0:
        if min != 0.0:
            deg += 1.0
            min -= 60.0
        dir = 'S'
    if np.floor(min)==0:        
      return (u"%d\N{DEGREE SIGN}%s") % (np.abs(deg),dir)
    else:  
      return (u"%d\N{DEGREE SIGN} %g' %s") % (np.abs(deg),np.abs(min),dir)
  
def lon2str(deg):
    min = 60 * (deg - np.floor(deg))
    deg = np.floor(deg)
    dir = 'E'
    if deg < 0:
        if min != 0.0:
            deg += 1.0
            min -= 60.0
        dir = 'W'
    if np.floor(min)==0:        
      return (u"%d\N{DEGREE SIGN}%s") % (np.abs(deg),dir)
    else:  
      return (u"%d\N{DEGREE SIGN} %g' %s") % (np.abs(deg),np.abs(min),dir)

   
def basemap_usgs(points,bathy,cont_range,ss):
    # plot the coastline and, if bathy is True, bathymetry is plotted
    # lat and lon can be any list of positions in decimal degrees
    #parallels_interval is the tick interval on axis
    #cont_range is the depth contours to plot
    #ss is the subsample rate to make things quicker
    lon = points['lons']
    lat = points['lats']

    #url='http://geoport.whoi.edu/thredds/dodsC/bathy/crm_vol1.nc'
    def get_index_latlon():# use the function to calculate the minlat,minlon,maxlat,maxlon location

        base_url='http://coastwatch.pfeg.noaa.gov/erddap/griddap/usgsCeSrtm30v6.nc?'
        isub=1  # make isub =1 in production mode
        if type(lat)!=float:
          query='topo[(%f):%d:(%f)][(%f):%d:(%f)]' % (max(lat),isub,min(lat),min(lon),isub,max(lon))
        else:
          query='topo[(%f):%d:(%f)][(%f):%d:(%f)]' % (lat+3.1,isub,lat-3.1,lon-3.1,isub,lon+3.1)
        url = base_url+query
        file='usgsCeSrtm30v6.nc'
        urllib.urlretrieve (url, file)
        nc = netCDF4.Dataset(file)
        ncv = nc.variables
    
        basemap_lat=ncv['latitude'][:]
        basemap_lon=ncv['longitude'][:]
        basemap_topo=ncv['topo'][:]
        #print basemap_lat
        # add the detail of basemap
        minlat=min(lat)#-0.01
        maxlat=max(lat)#+0.01
        minlon=min(lon)#-0.01
        maxlon=max(lon)#+0.01
        print minlat,maxlat
        index_minlat=int(round(np.interp(minlat,basemap_lat,range(0,basemap_lat.shape[0]))))
        index_maxlat=int(round(np.interp(maxlat,basemap_lat,range(0,basemap_lat.shape[0]))))
        index_minlon=int(round(np.interp(minlon,basemap_lon,range(0,basemap_lon.shape[0]))))
        index_maxlon=int(round(np.interp(maxlon,basemap_lon,range(0,basemap_lon.shape[0]))))
        print index_minlat,index_maxlat
        return index_minlat,index_maxlat,index_minlon,index_maxlon,basemap_lat,basemap_lon,basemap_topo
    
    index_minlat,index_maxlat,index_minlon,index_maxlon,basemap_lat,basemap_lon,basemap_topo = get_index_latlon()
 
    min_index_lat=min(index_minlat,index_maxlat)
    max_index_lat=max(index_minlat,index_maxlat)
    min_index_lon=min(index_minlon,index_maxlon)
    max_index_lon=max(index_minlon,index_maxlon)
    #ss=5 #subsample
    print "Using the USGS high res bathy with topo indexes: "+str(min_index_lat)+','+str(max_index_lat)+','+str(min_index_lon)+','+str(max_index_lon)
    X,Y=np.meshgrid(basemap_lon[min_index_lon:max_index_lon:ss],basemap_lat[min_index_lat:max_index_lat:ss])

    # You can set negative contours to be solid instead of dashed:
    matplotlib.rcParams['contour.negative_linestyle'] = 'solid'
    if bathy==True:
        #CS=plt.contourf(X,Y,basemap_topo.topo[min_index_lat:max_index_lat:ss,index_minlon:index_maxlon:ss],cont_range)#,colors=['0.8'])#,linewith=0.05)#cont_range)#,colors=['0.75','0.80','0.85','0.90'],linewith=0.05)
        CS=plt.contour(X,Y,basemap_topo[min_index_lat:max_index_lat:ss,index_minlon:index_maxlon:ss],cont_range,linewidths=0.5)#cont_range)#,colors=['0.75','0.80','0.85','0.90'],linewith=0.05)
        plt.clabel(CS, fmt='%5.0f m', colors='b', fontsize=8)


    if min_index_lat==max_index_lat:
        print "No basemap_usgs data available for this area"
    else: 
        plt.contourf(X,Y,basemap_topo[min_index_lat:max_index_lat:ss,min_index_lon:max_index_lon:ss],[0,1000],colors='0.5')
        
########animation    

points = {'lats':[],'lons':[]}  # collect all points we've gained
lons = []; lats = []; loop_num = []; times =[]; ctime = []; toltime = [] #mint = []; maxt = []

for i in idlist:
    index = np.where(df[0]==i)[0]
    ddata = df.ix[index]; 
    points['lons'].extend(ddata[7]); points['lats'].extend(ddata[8])
    ts = []; ds = []
    for j in range(len(ddata)):
        year=basetime.year
        if np.array(ddata[2])[j]!=1 and np.array(ddata[3])[j]!=1:
            basetime=datetime(2016,1,1)
        strt='%i-' %year+str(np.array(ddata[2])[j])+'-'+str(np.array(ddata[3])[j])+' '+str(np.array(ddata[4])[j])+':'+str(np.array(ddata[5])[j])    
        temptime = datetime.strptime(strt,'%Y-%m-%d %H:%M')
        ts.append(temptime) #'''
        ths = (temptime - basetime).total_seconds()/3600
        ds.append(int(round(ths)))
    #mint.append(min(ds)); maxt.append(max(ds))
    times.append(np.array(ts)); ctime.append(np.array(ds)); toltime.extend(ds)
    lons.append(np.array(ddata[7])); lats.append(np.array(ddata[8]))
    loop_num.append(len(ddata[7]))

#mintime = min(mint); maxtime = max(maxt)
#mtime = range(mintime,maxtime+1)
toltime = set(toltime); 
toltime = list(toltime); toltime.sort(); print 'plotting...',len(toltime)
print toltime


if result == 'plot':
    for i in range(len(lons)):
        plt.plot(lons[i],lats[i],'-',color = colors[i%10],markersize=20)

#ax.plot(drifter_points['lon'],drifter_points['lat'],'bo-',markersize=6,label='Drifter')
'''ax.annotate(an2,xy=(dr_points['lon'][-1],dr_points['lat'][-1]),xytext=(dr_points['lon'][-1]+0.01*track_days,
            dr_points['lat'][-1]+0.01*track_days),fontsize=6,arrowprops=dict(arrowstyle="fancy"))#'''

if result == 'animation':
    length = 1; 
    if len(toltime)>1000:
        length = 10
    print 'frame:',len(toltime)
    def animate(n): # the function of the animation
        del ax.lines[:]#del ax.collections[:]ax.cla()
        supt = (basetime + timedelta(hours=toltime[n])).strftime('%m-%d %H:%M')
        plt.suptitle('%s  \n time: %s'%(title,supt))      
       
        for i in range(len(lons)):
            c = colors[i%10]
            if toltime[n] < ctime[i][0]:
                ax.plot(lons[i][0],lats[i][0],'o-',color=c,markersize=0)
            elif toltime[n] > ctime[i][-1]:
                ax.plot(lons[i][-1],lats[i][-1],'o-',color=c,markersize=10)
            #if len(lons[i])>(n+1):        
            #if toltime[n] in ctime[i]:
            #if toltime[n]>=ctime[i][0] and toltime[n]<=ctime[i][-1]:
            else:
                abct = ctime[i] - toltime[n]
                ni = np.argmin(abs(abct)); 
                if ni<drpoint_number*length :
                    while(ni>=0):
                        ax.plot(lons[i][ni],lats[i][ni],'o-',color=c,markersize=(ni+1))
                        
                        ni=ni-1*length
                else:
                    pointsize=5
                    #draw  the line between 2 drifter points
                    if track=='line':
                        pointsize=5
                        for a in range(drpoint_number+1):
                            ax.plot(lons[i][ni-a*length],lats[i][ni-a*length],'o-',color=c,markersize=pointsize+1)
                            ax.plot([lons[i][ni-(a+1)*length],lons[i][ni-a*length]],[lats[i][ni-(a+1)*length],lats[i][ni-a*length]],'-', color=c,linewidth=pointsize)
                            pointsize=pointsize-1
                        
                    elif track=='point':
                        pointsize=10
                        for a in range(drpoint_number+1):

                            ax.plot(lons[i][ni-a*length],lats[i][ni-a*length],'o-',color=c,markersize=pointsize+1)
                            for ap in range(add_points+1):
                                ax.plot((lons[i][ni-(a+1)*length]+lons[i][ni-a*length])*ap/(add_points+1),(lats[i][ni-(a+1)*length]+lats[i][ni-a*length])*ap/(add_points+1),'o-',color=c,markersize=pointsize-1)
                            pointsize=pointsize-2
                            
    anim = animation.FuncAnimation(fig, animate, frames=len(toltime), interval=50) #
    if mapmethod=='etopo' or mapmethod=='bluemarble':
        fig = plt.figure(figsize=(10,9)) #figsize=(16,12)
        #can use this to control where the picture is 
        ax = fig.add_subplot(111)
        draw_basemap(ax, points)  # points is using here
        anim = animation.FuncAnimation(fig, animate, frames=ailoops, interval=100) 
    elif mapmethod=='usgs':
        fig = plt.figure(figsize=(10,9)) #figsize=(16,12)
        #can use this to control where the picture is 
        ax = fig.add_subplot(111)
        basemap_usgs(points,True,[-100,-50,0],1)
        thismanager3 = pylab.get_current_fig_manager()
        anim = animation.FuncAnimation(fig, animate, frames=ailoops, interval=100) 
    en_run_time = datetime.now()
    anim.save(save_dir+'%s.gif'%(filename[:-4]),writer='imagemagick',dpi=100)
    
    
#compare to the 'animation','banimation' is more fit the file which have more drifter  or more data 
if result == 'banimation':
    seglength = 10; 
    ailoops = int(len(toltime)/seglength)
    print 'frame:',ailoops
    def animate(n):
        del ax.lines[:]#del ax.collections[:]ax.cla()
        n = seglength*n; #print n
        supt = (basetime + timedelta(hours=toltime[n])).strftime('%Y-%m-%d %H:%M')
        plt.suptitle('%s  \n time: %s'%(title,supt),fontsize=12)   
        
        for i in range(len(lons)): #loop drifters
            
            c = colors[i%10]
            if track=='line':
                if toltime[n] > ctime[i][-1]:
                    if toltime[n-seglength]<ctime[i][-1]:
                        lki = ctime[i] - toltime[n-seglength]
                        nik = np.argmin(abs(lki));
                        wlp = len(ctime[i])-nik
                        for j in range(wlp):
                            ax.plot(lons[i][-(j+1)],lats[i][-(j+1)],'o-',color=c,markersize=wlp-j+1,markeredgecolor = 'none')                  

                        
                    '''else:
    
                        ax.plot(lons[i][-1],lats[i][-1],'o-',color=c,markersize=10)'''
                else:
    
                    abct = ctime[i] - toltime[n]
                    ni = np.argmin(abs(abct)); 
                    
                    if ni<seglength:

                        while (ni>=0):
                            ax.plot(lons[i][ni],lats[i][ni],'o',color=c,markersize=ni+1,markeredgecolor = 'none')
                            ni=ni-1

                    else:
                        for k in range(seglength):

                            ax.plot(lons[i][ni-k],lats[i][ni-k],'o-',color=c,markersize=0.5*seglength-0.5*k+0.5,markeredgecolor = 'none')
                            ax.plot([lons[i][ni-k-1],lons[i][ni-k]],[lats[i][ni-k-1],lats[i][ni-k]],'-', color=c,linewidth=0.5*seglength-0.5*k)                           

            elif track=='point':
                if toltime[n] > ctime[i][-1]:
                    if toltime[n-seglength]<ctime[i][-1]:
                        lki = ctime[i] - toltime[n-seglength]
                        nik = np.argmin(abs(lki)); 
                        wlp = len(ctime[i])-nik
                        for j in range(wlp):
                            ax.plot(lons[i][-(j+1)],lats[i][-(j+1)],'o-',color=c,markersize=wlp-j+1,markeredgecolor = 'none')                  

                        
                    else:
    
                        ax.plot(lons[i][-1],lats[i][-1],'o-',color=c,markersize=10)
                else:
    
                    abct = ctime[i] - toltime[n]
                    ni = np.argmin(abs(abct)); 
                    
                    if ni<seglength:
                        while (ni>=0):
                            ax.plot(lons[i][ni],lats[i][ni],'o',color=c,markersize=ni+1,markeredgecolor = 'none')
                            ni=ni-1

                    else:

                        for k in range(seglength):
                            ax.plot(lons[i][ni-k],lats[i][ni-k],'o-',color=c,markersize=seglength-k,markeredgecolor = 'none')


    
    if mapmethod=='etopo' or mapmethod=='bluemarble':
        fig = plt.figure(figsize=(10,9)) #figsize=(16,12)
        #can use this to control where the picture is 
        ax = fig.add_subplot(111)
        draw_basemap(ax, points)  # points is using here
        anim = animation.FuncAnimation(fig, animate, frames=ailoops, interval=100) 
    elif mapmethod=='usgs':
        fig = plt.figure(figsize=(10,9)) #figsize=(16,12)
        #can use this to control where the picture is 
        ax = fig.add_subplot(111)
        basemap_usgs(points,True,[-100,-50,0],1)
        plt.legend()
        thismanager3 = pylab.get_current_fig_manager()
        anim = animation.FuncAnimation(fig, animate, frames=ailoops, interval=100) 
    en_run_time = datetime.now()
    # mencoder,imagemagick,ffmpeg
anim.save(save_dir+'%s.gif'%(filename[:-4]),writer='imagemagick',dpi=100)#file name
plt.show()
